library(tidyverse)
source("figCore.R")

## This file contains scripts to generate all network metrics used in the manuscript. 
## Please run the dataGen.R script before running this script. 

### Influence Matrix related ----
## Group strenght calculation. Not used in the manuscript
groupCalcHybridness <- function(topoFile,remNodes = NULL)
{#browser()
    print(topoFile)
    inflFile <- paste0("Influence/", str_replace(topoFile, ".topo", ".csv"))
    inflMat <- read.csv(inflFile)
    
    nodes <- inflMat[[1]]
    rownames(inflMat) <- nodes
    df <- as.matrix(inflMat[,-1])
    if (!is.null(remNodes))
    {
        ids <- which(nodes %in% remNodes)
        nodes <- nodes[-ids]
        df <- df[-ids, -ids]
    }
    df1 <- apply(df, 2, function(x){
        ifelse(x > 0, 1, -1)
    })
    df1 <- cbind(df1, t(df1))
    hc <- hclust(dist(df1))
    clust <- cutree(hc, 2)
    g1 <- nodes[clust == 1] %>% sort
    g2 <- nodes[clust == 2] %>% sort
    if(g1[length(g1)]> g2[1])
    {
        g0 <- g1
        g1 <- g2
        g2 <- g0
    }
    nOrder <- c(g1,g2)
    df2 <- data.frame(df) %>% mutate(nodes1 = nodes) %>%
        gather(key = "Nodes", value = "Influence", -nodes1) %>%
        mutate(nodes1 = factor(nodes1, levels = nOrder), Nodes = factor(Nodes, levels = nOrder))
    
    g11 <- df[g1,g1] %>% as.vector %>% mean
    g22 <- df[g2,g2] %>% as.vector %>% mean
    g12 <- df[g1,g2] %>% as.vector %>% mean
    g21 <- df[g2,g1] %>% as.vector %>% mean
    Gs <- sum(c(g11, g22, g12, g21) %>% abs)/4
    InflVal1 <- df %>% abs %>% sum
    InflVal2 <- df[df < 0] %>% sum
    return(c(Gs, InflVal1, InflVal2))
}
groupCalcHybridness <- cmpfun(groupCalcHybridness)

## Collates the influence based feeback loops.
InfluenceGen <- function(folder){
    # setwd(boolRaw)
    setwd(folder)
    topoFiles <- list.files(".", ".topo")
    df <- sapply(topoFiles, function(x){
        net <- x %>% str_remove(".topo")
        Gmets <- groupCalcHybridness(x)
        InflLoops <- read.csv(paste0("InflLoops/", net, "_inflLoops.csv")) %>%
            group_by(Type) %>% summarise(Strength = sum(Strength))
        inflTS <- InflLoops %>% filter(Type == "TS") %>% select(Strength) %>% unlist %>% sum
        inflDA <- InflLoops %>% filter(Type == "DA") %>% select(Strength) %>% unlist %>% sum
        inflnegLoops <- InflLoops %>% filter(Type == "NF") %>% select(Strength) %>% unlist %>% sum
        inflposLoops <- inflTS + inflDA
        return(c(Gmets, inflTS, inflDA, inflposLoops, inflnegLoops))
    }) %>% t %>% data.frame %>% 
        set_names(c("Gs", "InflVal", "InflVal2", "inflTS", "inflDA", "inflposLoops", "inflnegLoops")) %>%
        mutate(Network = str_remove(topoFiles, ".topo"))
    setwd("..")
    return(df)
}

### Loops related ----

## This function collates all the directed loops files generated by dataGen.R
loopsDat <- function()
{
    # browser()
    filz <- c(list.files(".", "\\d.csv"), "wild.csv")
    nets <- filz %>% str_remove(".csv")
    loops <- sapply(filz, function(x){
        df <- read.csv(x) 
        d <- df %>% group_by(Nature) %>% summarise(Count = n(), Weighted = sum(1/Edge_count)) %>%
            arrange(Nature)
        posLoops <- filter(d, Nature == "P") %>% select(-Nature) %>% unlist
        if(is_empty(posLoops))
            posLoops <- c(0,0)
        negLoops <- filter(d, Nature == "N") %>% select(-Nature) %>% unlist
        if(is_empty(negLoops))
            negLoops <- c(0,0)
        predFrust <- df %>% filter(Edge_count <= 6, Edge_count > 1, Nature == "N") %>% nrow
        smallPFL <- df %>% filter(Edge_count <= 6, Edge_count > 1, Nature == "P") %>% nrow
        c(posLoops, negLoops, predFrust, smallPFL)
    }) %>% t %>% data.frame %>% set_names(c( "posLoops", "posWeighted", 
                                             "negWeighted", "negLoops", "predFrust",
                                             "smallPFL")) %>%
        mutate(Network = nets) %>% naZero
    loops
    
}

### Functions to calculate network consistency

consistencyFormatting <- function(net, edges, edgeNames)
{
    cycles <- read_csv(paste0(net, "_undirectedLoops.csv"), lazy = F) %>% select(Cycles) %>% unlist
    cycleDat <- lapply(cycles, function(cyc){
        nodes <- str_split(cyc, ",")[[1]]
        if(length(nodes) == 1)
        {
            ed <- data.frame(Edge1 = paste0(nodes, ",", nodes))
        }
        else
        {
            nodes <- c(nodes, nodes[1])
            ed <- lapply(1:(length(nodes)-1), function(i){
                e <- c(nodes[i], nodes[i+1])
                e <- list(e, rev(e)) %>% sapply(paste0, collapse = ",")
                e <- e[which(e %in% edgeNames)]
            }) %>% expand.grid %>% set_names(paste0("Edge", 1:ncol(.)))
        }
        
        ed %>% mutate(Nature = ed %>% apply(1, function(e){edges[e] %>% prod})) %>%
            mutate(Nature = ifelse(Nature == 1, "P", "N")) %>% 
            unite("EdgeList",contains("Edge"), sep = ";") %>%
            mutate(Cycles = cyc, Edge_count = str_count(EdgeList, ";") + 1)
    }) %>% reduce(rbind.data.frame)
    cycleDat
}

consistency <- function(net, compute = F)
{
    loopFile <- paste0(net, "_Consistency.csv")
    if (!file.exists(loopFile) || compute)
    {
        topoFiles <- list.files(".", ".topo")
        nets <- topoFiles %>% str_remove(".topo")
        loopData <- sapply(nets, function(x){
            topoDf <- read.delim(paste0(x, ".topo"), sep = "") %>% 
                unite(col = "Edge",sep = ",", Source, Target) %>% 
                mutate(Type = ifelse(Type == 2, -1, 1))
            edges <- topoDf$Type
            names(edges) <- topoDf$Edge
            edgeNames <- names(edges)
            setwd("undirectedLoops")
            df <- consistencyFormatting(x, edges, edgeNames)
            setwd("..")
            # browser()
            # d <- read.csv(paste0("undirectedLoops/",x, "_undirectedLoops.csv"))
            posLoops <- c(sum(df$Nature == "P"), 
                          df %>% filter(Nature == "P") %>% mutate(Edge_count = 1/Edge_count) %>% 
                              select(Edge_count) %>% unlist %>% sum)
            negLoops <- c(sum(df$Nature == "N"), 
                          df %>% filter(Nature == "N") %>% mutate(Edge_count = 1/Edge_count) %>% 
                              select(Edge_count) %>% unlist %>% sum)
            fracNeg <- negLoops[1]/(negLoops[1] + posLoops[1])
            print(x)
            write.csv(df, paste0("undirectedLoops/",x, "_undirectedLoopsF.csv"), row.names = F)
            df$ID <- 1:nrow(df)
            edgeDat <- lapply(edgeNames, function(e){
                df %>% filter(str_detect(EdgeList, e)) %>% group_by(Nature) %>%
                    summarise(Count = n(), loops = paste0(ID, collapse = ",")) %>% 
                    mutate(Edge = e)
            }) %>% reduce(rbind.data.frame) %>% 
                mutate(Nature = factor(Nature, levels = c("P", "N"))) %>% 
                spread(key = Nature, value = Count)
            if (!("P" %in% colnames(edgeDat)))
                edgeDat$P <- 0
            if (!("N" %in% colnames(edgeDat)))
                edgeDat$N <- 0
            edgeDat[is.na(edgeDat)] <- 0
            negDat <- edgeDat %>% filter(P == 0) %>% arrange(-N)
            posDat <- edgeDat %>% filter(N == 0)
            mixDat <- edgeDat %>% filter(P != 0, N != 0)
            nLoops <- df$ID[df$Nature == "N"]
            coveredLoops <- c()
            swapEdges <- 0
            if(nrow(negDat) != 0)
            {
                dummy <- sapply(negDat$loops, function(l){
                    l <- l %>% str_split(",") %>% unlist %>% as.integer
                    i <- intersect(coveredLoops, l)
                    if (is.null(i) || length(i) < length(l))
                    {
                        coveredLoops <<- c(coveredLoops, l) %>% unique
                        swapEdges <<- swapEdges + 1
                    }
                })
                if (length(coveredLoops) < length(nLoops))
                {
                    remaining <- nLoops[!(nLoops %in% coveredLoops)]
                    dat <- edgeDat %>% 
                        filter(sapply(loops, function(l){
                            any(str_detect(l, as.character(remaining)))
                        }))
                    loops <- paste0(dat$loops, collapse = ",") %>% str_split(",") %>%
                        unlist %>% as.integer
                    pLoops <- loops[!(loops %in% remaining)]
                    dummy <- sapply(dat$loops, function(l){
                        l <- l %>% str_split(",") %>% unlist %>% as.integer
                        l <- l[!(l %in% pLoops)]
                        i <- intersect(coveredLoops, l)
                        if (is.null(i) || length(i) < length(l))
                        {
                            coveredLoops <<- c(coveredLoops, l) %>% unique
                            swapEdges <<- swapEdges + 1
                            return(T)
                        }
                        return(F)
                    })
                    ed <- dat$Edge[dummy]
                    dat <- edgeDat %>% 
                        filter(sapply(loops, function(l){
                            any(str_detect(l, as.character(pLoops)))
                        })) %>% filter(!(Edge %in% ed))
                    coveredLoops <- c()
                    dummy <- sapply(dat$loops, function(l){
                        l <- l %>% str_split(",") %>% unlist %>% as.integer
                        i <- intersect(coveredLoops, l)
                        if (is.null(i) || length(i) < length(l))
                        {
                            coveredLoops <<- c(coveredLoops, l) %>% unique
                            swapEdges <<- swapEdges + 1
                            return(T)
                        }
                        return(F)
                    })
                    
                }
            }
            c(posLoops, negLoops, swapEdges)
        }) %>% t %>% data.frame %>% 
            set_names(c("posLoopsUnd", "posLoopsUndWeighted","negLoopsUnd", "negLoopsUndWeighted",
                        "inconsistency")) %>%
            mutate(Net = nets)
        write.csv(loopData, paste0(net, "_Consistency.csv"), row.names = F)
    }
    read.csv(paste0(net, "_Consistency.csv")) %>% mutate(Network = Net) %>% 
        select(-Net)
}

# function to calculate hiloops

hiLoops <- function(net) {
    # browser()
    source(paste0(cwd, "/topoTogxml.R"))
    cmd <- paste0("python ",hiLoopCode, " ", net, " --maxcycle 5 --maxnodes 10 -q")
    system(cmd)
    read.csv(paste0(net, "_hiLoops.csv"))
}

### Compile network metrics ----

# This function assumes that the current folder contains folders each corresponding to 
# one EMP network, with the corresponding topoFiles. The topofiles in said format for 
# edge deletion and random networks have been added to the github repo. 

allNetMetrics <- function()
{
    # setwd(boolRaw)
    wd <- getwd()
    folders <- list.dirs(".", recursive = F) %>% str_remove("./")
    # folders <- folders[1]
    dummy <- sapply(folders, function(x){
        dfInfl <- InfluenceGen(x) %>% mutate(Network = str_replace_all(Network, "-", "_"))
        setwd(x)
        net <- x
        dfLoops <- loopsDat() %>% mutate(Network = str_replace_all(Network, "-", "_"))
        dfCons <- consistency(net) %>% mutate(Network = str_replace_all(Network, "-", "_"))
        dfhiLoops <- hiLoops(net) %>% mutate(Network = str_replace_all(Network, "-", "_"))
        df <- list(dfInfl, dfLoops, dfCons, dfhiLoops) %>%
            reduce(merge, by = "Network", all = T)
        setwd(dataFolder)
        setwd("NetMetrics")
        write.csv(df, paste0(x %>% str_remove_all("-"), "_randNetMetrics.csv"), row.names = F)
        setwd(wd)
    })
}

allNetMetrics()

